name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest
    env:
      # On va définir KUBECONFIG en variable d'environnement globale au job.
      # On stocke le kubeconfig dans $HOME/kubeconfig
      KUBECONFIG: ${{ github.workspace }}/kubeconfig

    steps:
      # 1. Récupération du code
      - uses: actions/checkout@v3

      # 2. Configuration du KUBECONFIG depuis un secret
      - name: Set KUBECONFIG
        run: |
          echo "${{ secrets.KUBECONFIG }}" > ${{ github.workspace }}/kubeconfig
          chmod 600 ${{ github.workspace }}/kubeconfig

          echo "KUBECONFIG=$PWD/kubeconfig" >> $GITHUB_ENV
          kubectl get nodes

      # 3. Installation de Terraform
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.5.0

      # 4. Terraform init/plan/apply
      - name: Terraform Init
        working-directory: ./infrastructure
        run: terraform init

      - name: Terraform Import Resources
        working-directory: ./infrastructure
        run: |
          terraform import kubernetes_namespace_v1.monitoring monitoring
          terraform import kubernetes_namespace_v1.webgoat webgoat
          terraform import kubernetes_deployment.prometheus monitoring/prometheus
          terraform import kubernetes_service.prometheus monitoring/prometheus

      - name: Terraform Plan
        working-directory: ./infrastructure
        run: terraform plan

      - name: Terraform Apply
        working-directory: ./infrastructure
        run: terraform apply -auto-approve

      # 5. Installation d’Ansible
      - name: Install Ansible
        run: |
          sudo apt-get update
          sudo apt-get install -y ansible

      # 6. Configuration SSH si nécessaire (optionnel)
      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      # 7. Exécution du playbook Ansible
      - name: Run Ansible Playbook
        run: |
          ansible-playbook -i ansible/inventory.ini ansible/deploy.yml --ssh-common-args='-o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null'

      # 8. Déploiement sur Kubernetes
      - name: Create namespaces
        run: |
          kubectl create namespace monitoring || true
          kubectl create namespace webgoat || true

      - name: Deploy Prometheus, Grafana, WebGoat
        run: |
          kubectl apply -f kubernetes/prometheus/
          kubectl apply -f kubernetes/grafana/
          kubectl apply -f kubernetes/deployment.yaml
          kubectl apply -f kubernetes/service.yaml
          kubectl apply -f kubernetes/quotas.yaml

      # 9. Attendre la disponibilité des pods
      - name: Wait for Prometheus
        run: kubectl -n monitoring wait --for=condition=ready pod -l app=prometheus --timeout=300s

      - name: Wait for Grafana
        run: kubectl -n monitoring wait --for=condition=ready pod -l app=grafana --timeout=300s

      - name: Wait for WebGoat
        run: kubectl -n webgoat wait --for=condition=ready pod -l app=webgoat --timeout=300s

      # 10. Afficher les URLs d’accès
      - name: Show Access URLs
        run: |
          echo "WebGoat: http://20.63.16.243:31051/WebGoat"
          echo "Prometheus: http://20.63.16.243:$(kubectl get svc -n monitoring prometheus -o jsonpath="{.spec.ports[0].nodePort}")"
          echo "Grafana: http://20.63.16.243:$(kubectl get svc -n monitoring grafana -o jsonpath="{.spec.ports[0].nodePort}")"
          echo "kube-state-metrics: http://20.63.16.243:31080/"
          echo "SonarQube: http://20.63.16.243:9000/"
